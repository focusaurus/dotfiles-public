#!/usr/bin/env bash

# Please Use Google Shell Style: https://google.github.io/styleguide/shell.xml

# ---- Start unofficial bash strict mode boilerplate
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -o errexit  # always exit on error
set -o errtrace # trap errors in functions as well
set -o pipefail # don't ignore exit codes when piping output
set -u          # error on reference to unknown variable
# set -x # enable debugging

IFS=$'\n\t'
# ---- End unofficial bash strict mode boilerplate

defaultBranch="main"
remoteBranch="origin/${defaultBranch}"

# Fetch to ensure we have latest remote state
git fetch origin "${defaultBranch}" --quiet 2>/dev/null || true

out=$(mktemp "/tmp/git-cleanup-squashed-XXX")
git for-each-ref refs/heads/ "--format=%(refname:short)" | {
  while IFS= read -r branch; do
    if [[ "${branch}" == "${defaultBranch}" ]]; then
      continue
    fi

    # Check if branch is ancestor of remote main (already merged or squash-merged)
    if git merge-base --is-ancestor "${branch}" "${remoteBranch}" 2>/dev/null; then
      echo "git branch --delete --force ${branch}" >>"${out}"
      continue
    fi

    # For squash merges: create synthetic commit and check via git cherry
    mergeBase=$(git merge-base "${remoteBranch}" "$branch" 2>/dev/null) || continue
    rev=$(git rev-parse "${branch}^{tree}")
    treeHash=$(git commit-tree "${rev}" -p "${mergeBase}" -m "$0:temp commit for ${branch}")
    cherry=$(git cherry "${remoteBranch}" "${treeHash}")

    if [[ "${cherry}" == "-"* ]]; then
      echo "git branch --delete --force ${branch}" >>"${out}"
      continue
    fi

    # Secondary check: see if remote main contains equivalent changes
    # This catches cases where the squash commit differs slightly (rebased, amended, etc.)
    # Compare the diff of branch vs merge-base to diffs in remote main
    branchDiff=$(git diff "${mergeBase}".."${branch}" 2>/dev/null | git hash-object --stdin)
    found=false
    while IFS= read -r commit; do
      [[ -z "${commit}" ]] && continue
      commitDiff=$(git diff "${commit}^".."${commit}" 2>/dev/null | git hash-object --stdin) || continue
      if [[ "${branchDiff}" == "${commitDiff}" ]]; then
        found=true
        break
      fi
    done < <(git log --oneline "${mergeBase}".."${remoteBranch}" --format="%H" 2>/dev/null | head -50)

    if [[ "${found}" == "true" ]]; then
      echo "git branch --delete --force ${branch}" >>"${out}"
    else
      echo -e "keep:\t${branch}"
    fi
    # echo "cherry is ${cherry}"
    # if [[ $(git cherry "${defaultBranch}" $(git commit-tree $(git rev-parse "$branch^{tree}") -p "$mergeBase" -m _)) == "-"* ]]; then
    # echo "$branch is merged into ${defaultBranch} and can be deleted"
    # else
    # echo "$branch has unmerged commits"
    # fi
  done
}
echo "Script to delete squashed branches is: ${out}"
cat "${out}"
echo "source ${out}"
cat <<'EOF' >/dev/null
git config --global alias.delete-squashed '!f() {

local targetBranch=${1:-master}
git checkout -q $targetBranch
&& git branch --merged | grep -v "\*" | xargs -n 1 git branch -d
&& git for-each-ref refs/heads/ "--format=%(refname:short)" | while read branch; do mergeBase=$(git merge-base $targetBranch $branch)
&& [[ $(git cherry $targetBranch $(git commit-tree $(git rev-parse $branch^{tree}) -p $mergeBase -m _)) == "-"* ]]
&& git branch -D $branch; done;

}; f'


git checkout -q master && git for-each-ref refs/heads/ "--format=%(refname:short)" | while read branch; do mergeBase=$(git merge-base master $branch)
&& [[ $(git cherry master $(git commit-tree $(git rev-parse "$branch^{tree}") -p $mergeBase -m _)) == "-"* ]] && echo "$branch is merged into master and can be deleted"; done
EOF
